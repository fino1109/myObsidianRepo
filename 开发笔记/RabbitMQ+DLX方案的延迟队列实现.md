## 1.背景
之前用Redis的过期消息通知实现了延迟队列[[Redis实现延迟任务]]
是基于非重要&少量的边缘业务数据进行处理 设计到业务的核心逻辑 就需要考虑到进一步的支持可靠的持久化的实现方案
所以选择了RabbitMQ的实现方式

本次的业务需求:核心逻辑中部分判断条件的延迟生效 条件生效后再延迟失效


## 2.why dlx?
我所使用的RabbitMQ版本是3.8.2版本 支持3.5.7版本开始提供的延迟插件`rabbitmq_delayed_message_exchange`
但是因为之前没有配置插件+队列的上下游用户众多+避免企业资源浪费等诸多因素
最终选择使用DLX来实现延时处理的需求

## 3.DLX的实现及代码片段

### 3.1原理简述
新建一个普通的交换机和队列 作为生产者向其中发送消息 但是这一组不设置消费者 ttl到期后消息就会进入配置的死信交换机和队列 在死信队列后设置消费者 就可以实现延迟处理后续的逻辑



## 4.插件实现及代码片段

